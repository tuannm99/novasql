# NovaSQL

- NovaSQL is a Go database engine I built to learn how databases actually work under the hood.
- About 70% of the code is generated by ChatGPT (yes, Iâ€™m not ashamed), and the remaining 30% is me wiring things together, debugging, and trying not to break everything.
- This isnâ€™t a serious production DB â€” itâ€™s a sandbox for learning and experimenting.

---

## ğŸ” High-Level Overview

NovaSQL focuses on:

- **Page-based storage** with slotted pages
- **Buffer pool** with a CLOCK replacement policy
- **Heap tables** on top of pages
- **Index structures** (B+Tree â€“ in progress)
- **Write-Ahead Logging (WAL) & Transactions** (planned)
- **SQL front-end** (parser / planner / executor â€“ planned)

The project is structured to mirror real-world database engines (SQLite/PostgreSQL) but stays small enough to remain hackable and educational.

---

## âœ… Current Status

> What is actually implemented right now?

### Storage & Pages

- `StorageManager` for reading/writing fixed-size pages to disk
- `FileSet` abstraction for mapping logical files to on-disk files
  - `LocalFileSet` concrete implementation using the local filesystem
- `Page` structure
  - Slotted-page layout (tuple directory, free space in the middle)
  - Insert / read tuple primitives

> This is the foundation that everything else (heap, indexes, WAL) builds on.

### Buffer Pool (with CLOCK)

- `Pool` in `bufferpool` package:
  - Fixed-size array of `Frame`
  - `Manager` interface for table-level usage
  - Tracks:
    - `Pin` count (how many users are â€œholdingâ€ this page)
    - `Dirty` flag (needs to be flushed to disk)
- **Replacement Policy**: CLOCK (approximate LRU)
  - Each `Frame` has a `Ref` bit
  - On access â†’ `Ref = true`
  - When pool is full:
    - CLOCK hand sweeps over frames:
      - Pinned (`Pin > 0`) â†’ skip
      - `Ref == true` â†’ set to `false` (second chance)
      - `Ref == false` & `Pin == 0` â†’ victim

This gives NovaSQL a realistic, DB-style buffer manager instead of a naive â€œfirst unpinnedâ€ policy.

### Heap Tables

- `heap.Table` (very early version)
  - Uses:
    - `StorageManager` + `FileSet` for disk I/O
    - `bufferpool.Pool` for caching pages
  - Provides:
    - `InsertRow(values []any)` â†’ encode row â†’ write into a heap page
    - `ReadRow(slot)` via `HeapPage` â†’ decode row back
    - `UpdateRow(slot, values)` via `HeapPage` â†’ update row
    - `DeleteRow(slot)` via `HeapPage` â†’ decode row

Row encoding/decoding:

- `EncodeRow(schema, values)` / `DecodeRow` for turning Go values into on-page byte layouts.

> This layer is roughly comparable to a minimal â€œtable heapâ€ in PostgreSQL / SQLite.

---

## ğŸ›£ï¸ Roadmap

> What is planned next?

### Short-Term

- **B+Tree index**
  - Node layout on pages (internal/leaf)
  - Search, insert, split
  - Integration with the buffer pool (pages are loaded via `Pool`)
- **Better heap table API**
  - Iterators / scans
  - Simple predicates (filtering)

### Mid-Term

- **Write-Ahead Logging (WAL)**
  - Log record format
  - Redo / Undo basics
  - Crash recovery for dirty pages

- **Transaction layer**
  - Simple transaction manager
  - Basic locking / latches around pages & tuples
  - Simple isolation (e.g. read committed)

- **Query layer**
  - Minimal SQL subset:
    - `CREATE TABLE`
    - `INSERT`
    - `SELECT` with simple predicates
  - AST â†’ logical plan â†’ physical plan

### Long-Term (Exploration Ideas)

- More index types: Hash index, LSM-Tree
- Advanced join algorithms
- Better isolation levels (Snapshot, Serializable)
- Backup / restore
- Compression
- Distributed / sharding experiments

---

## ğŸ§± Architecture

At a high level:

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                Client Layer                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚  (SQL text / driver)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Query Processor               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   Parser    â”‚â”€â”€â–¶ Optimizer â”‚â”€â”€â–¶ Exec  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚  (logical ops: scan, join, filter)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Storage Engine                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   Tables    â”‚  â”‚  Indexes  â”‚  â”‚  WAL  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚  (logical pages)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            Buffer Pool + Pages             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚  BufferPool â”‚  â”‚   Pages   â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚  (physical pages)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Disk Management               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

```


## ğŸ¤” Challenges & Future Exploration

The journey of building NovaSQL has revealed many areas for future exploration:

- Advanced compression algorithms
- Distributed database concepts
- Streaming capabilities
- Column-store implementation
- Time-series optimizations
- Graph database extensions

## ğŸ™ Acknowledgements

This project draws inspiration from various database systems and educational resources, including:
- SQLite
- PostgreSQL
- CMU Database Systems Course
- Various systems programming books and resources
