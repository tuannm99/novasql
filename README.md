# NovaSQL

- NovaSQL is a Go database engine I built to learn how databases actually work under the hood.
- About 70% of the code is generated by ChatGPT (yes, Iâ€™m not ashamed), and the remaining 30% is me wiring things together, debugging, and trying not to break everything.
- This isnâ€™t a serious production DB â€” itâ€™s a sandbox for learning and experimenting.

---

## ğŸ” High-Level Overview

NovaSQL focuses on:

- **Page-based storage** with slotted pages
- **Buffer pool** with a CLOCK replacement policy
- **Heap tables** on top of pages
- **Index structures** (B+Tree â€“ in progress)
- **Write-Ahead Logging (WAL) & Transactions** (planned)
- **SQL front-end** (parser / planner / executor â€“ planned)

The project is structured to mirror real-world database engines (SQLite/PostgreSQL) but stays small enough to remain hackable and educational.

---

## âœ… Current Status

> What is actually implemented right now (based on the code you showed: Storage/Page + GlobalPool/View + Heap + B+Tree + Database meta).

### 1) Storage & Pages

- `StorageManager`
  - Reads/writes **fixed-size pages** to disk for a given `FileSet`
  - `CountPages(fs)` to get the on-disk page count for a relation
- `FileSet` abstraction
  - `LocalFileSet{Dir, Base}` is the main implementation (and is required by `GlobalPool`)
  - Segment operations:
    - `RemoveAllSegments(fs)`
    - `RenameAllSegments(old, new)`
- `Page`
  - **slotted-page layout** (tuple directory + free space)
  - tuple insert/read primitives by slot
  - `PageID()` is used to identify a page

---

### 2) Buffer Pool

#### âœ… GlobalPool (shared buffer pool)

- `bufferpool.GlobalPool`
  - **one shared pool for ALL relations** (heap / index / overflow)
  - page identity is:
    - `PageTag{ FSKey: "Dir|Base", PageID }`
  - each frame contains:
    - `FS storage.LocalFileSet` (required for correct flush)
    - `Pin`, `Dirty`, `Page`

#### âœ… Replacement Policy: CLOCK

- CLOCK-based eviction:
  - pinned (`Pin > 0`) pages are not evictable
  - ref-bit logic is handled by the CLOCK adapter

#### âœ… FileSetView (relation-scoped Manager)

- `FileSetView` binds `(GlobalPool + FileSet)` and implements `bufferpool.Manager`
- lets `heap.Table` / `btree.Tree` use a â€œper-relation managerâ€ API
- `Database` caches views by `"Dir|Base"`

---

### 3) Heap Tables

- `heap.Table`
  - uses:
    - `StorageManager`
    - heap `FileSet`
    - `bufferpool.Manager` (**now via View**)
    - `OverflowManager` (`*_ovf`)
  - supports:
    - `Insert(values)`
    - `Get(tid)`
    - `Scan(fn)`
    - `Update(tid, values)` (supports redirect)
    - `Delete(tid)`

#### âœ… Redirect semantics

- Update may enlarge a tuple â†’ write a new tuple elsewhere and mark the old slot as a **redirect**
- therefore:
  - `Get(oldTID)` still returns the latest row (follows redirect) âœ…
  - an index pointing to the old TID still â€œworksâ€ as long as the row isnâ€™t deleted âœ…

---

### 4) B+Tree Index (early)

- `btree.Tree`
  - persistent index pages on disk (index segments)
  - meta file:
    - `... .btree.meta.json` (root / height / nextPageID)
  - operations:
    - `Insert(key, tid)`
    - `SearchEqual(key)`
    - `RangeScan(min, max)`
  - supports duplicates (one key â†’ multiple TIDs)

---

### 5) Database Layer

- `novasql.Database`
  - manages `DataDir` and per-table JSON metadata
  - owns a **GlobalPool** similar to PostgreSQL `shared_buffers`
  - caches `views` per `"Dir|Base"`

Implemented:

- `CreateTable`, `OpenTable`
- `DropTable` (flush + drop cached pages before deleting files)
- `RenameTable` (flush + drop cached pages before renaming files)
- `ListTables`
- `FlushAllPools`, `Close`

Not implemented:

- `ListDatabase`, `SelectDatabase`, `DropDatabase`

---

## âš ï¸ What is NOT synced yet (expected)

### Index maintenance is NOT automatically synchronized with heap mutations

- Insert: in your manual tests you call `tree.Insert(...)` explicitly
- Update redirect:
  - index still points to old TID â†’ `Get(oldTID)` follows redirect âœ…
- Delete:
  - if you delete from heap only, the index entry becomes **dangling** âŒ
  - manual CASE C shows this (expected)

âœ… Conclusion: heap CRUD and index CRUD are still **separate** right now.  
Now keep synchronization in the **planner/executor** (execution layer) to make it logically atomic.

---

## âœ… Recommended behavior (for now)

- If want â€œtable + index correctnessâ€:
  - Insert: executor does `heap.Insert` â†’ get `tid` â†’ `index.Insert(key, tid)`
  - Delete: executor does `index.Delete(key, tid)` â†’ `heap.Delete(tid)`
  - Update:
    - if key unchanged: index entry can stay (redirect keeps old TID valid)
    - if key changes: remove old entry + insert new entry

---

## ğŸ›£ï¸ Roadmap

> What is planned next?

### Short-Term

- **B+Tree index**
  - Node layout on pages (internal/leaf)
  - Search, insert, split
  - Integration with the buffer pool (pages are loaded via `Pool`)
- **Better heap table API**
  - Iterators / scans
  - Simple predicates (filtering)

### Mid-Term

- **Write-Ahead Logging (WAL)**
  - Log record format
  - Redo / Undo basics
  - Crash recovery for dirty pages

- **Transaction layer**
  - Simple transaction manager
  - Basic locking / latches around pages & tuples
  - Simple isolation (e.g. read committed)

- **Query layer**
  - Minimal SQL subset:
    - `CREATE TABLE`
    - `INSERT`
    - `SELECT` with simple predicates
  - AST â†’ logical plan â†’ physical plan

### Long-Term (Exploration Ideas)

- More index types: Hash index, LSM-Tree
- Advanced join algorithms
- Better isolation levels (Snapshot, Serializable)
- Backup / restore
- Compression
- Distributed / sharding experiments

---

## ğŸ§± Architecture

At a high level:

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                Client Layer                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚  (SQL text / driver)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Query Processor               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   Parser    â”‚â”€â”€â–¶ Optimizer â”‚â”€â”€â–¶ Exec  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚  (logical ops: scan, join, filter)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Storage Engine                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   Tables    â”‚  â”‚  Indexes  â”‚  â”‚  WAL  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚  (logical pages)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            Buffer Pool + Pages             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚  BufferPool â”‚  â”‚   Pages   â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚  (physical pages)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Disk Management               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

```

## ğŸ¤” Challenges & Future Exploration

The journey of building NovaSQL has revealed many areas for future exploration:

- Advanced compression algorithms
- Distributed database concepts
- Streaming capabilities
- Column-store implementation
- Time-series optimizations
- Graph database extensions

## ğŸ™ Acknowledgements

This project draws inspiration from various database systems and educational resources, including:

- SQLite
- PostgreSQL
- CMU Database Systems Course
- Various systems programming books and resources
